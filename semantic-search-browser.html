<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>AI 语义搜索演示 - 纯浏览器版</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 48px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
    }

    .header .subtitle {
      font-size: 20px;
      opacity: 0.9;
      margin-bottom: 20px;
    }

    .badges {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .badge {
      background: rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 1024px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: white;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .card-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      color: #333;
    }

    .status-section {
      margin-bottom: 20px;
    }

    .status-indicator {
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 10px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator.loading {
      background: #fff3cd;
      color: #856404;
    }

    .status-indicator.success {
      background: #d4edda;
      color: #155724;
    }

    .status-indicator.error {
      background: #f8d7da;
      color: #721c24;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
      width: 0%;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-top: 16px;
    }

    .stat-item {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-label {
      font-size: 12px;
      color: #6c757d;
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 24px;
      font-weight: 600;
      color: #667eea;
    }

    .search-section {
      margin-bottom: 20px;
    }

    .search-box {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
    }

    .search-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }

    .search-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .search-btn {
      padding: 12px 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .search-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .search-btn:active {
      transform: translateY(0);
    }

    .search-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .results-section {
      max-height: 500px;
      overflow-y: auto;
    }

    .result-item {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 12px;
      border-left: 4px solid #667eea;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .result-item:hover {
      transform: translateX(4px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .result-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .result-title {
      font-weight: 600;
      color: #333;
      font-size: 16px;
    }

    .result-similarity {
      background: #667eea;
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
    }

    .result-content {
      color: #555;
      line-height: 1.6;
      margin-bottom: 8px;
    }

    .result-meta {
      font-size: 12px;
      color: #6c757d;
    }

    .log-section {
      height: 400px;
      overflow-y: auto;
    }

    .log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 16px;
      border-radius: 8px;
      font-family: "Consolas", "Monaco", monospace;
      font-size: 13px;
      line-height: 1.6;
      max-height: 100%;
      overflow-y: auto;
    }

    .log-entry {
      margin-bottom: 4px;
      padding: 4px 0;
    }

    .log-entry.info {
      color: #4fc3f7;
    }

    .log-entry.success {
      color: #66bb6a;
    }

    .log-entry.error {
      color: #ef5350;
    }

    .log-entry.warning {
      color: #ffb74d;
    }

    .log-time {
      color: #888;
      margin-right: 8px;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: #667eea;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #764ba2;
    }

    .loading-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-left-color: #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>
        <span style="font-size: 64px">🚀</span>
        AI 语义搜索演示
      </h1>
      <div class="subtitle">纯浏览器版 + WASM 高性能版本</div>
      <div class="badges">
        <div class="badge">
          <span>⚡</span>
          <span>WASM 加速</span>
        </div>
        <div class="badge">
          <span>🎯</span>
          <span id="currentModel">未选择模型</span>
        </div>
        <div class="badge">
          <span>📚</span>
          <span>100+ 语言支持</span>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div class="card">
        <div class="card-title">
          <span>📊</span>
          <span>系统状态</span>
        </div>

        <div class="status-section">
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">
              选择模型：
            </label>
            <select id="modelSelect"
              style="width: 100%; padding: 10px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; cursor: pointer;">
              <option value="small" selected>multilingual-e5-small (116MB, 384维, 速度快)</option>
              <option value="base">multilingual-e5-base (279MB, 768维, 精度高)</option>
            </select>
          </div>

          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">
              相似度阈值：<span id="thresholdValue">50%</span>
            </label>
            <input type="range" id="thresholdSlider" min="0" max="100" value="50" style="width: 100%; cursor: pointer;"
              oninput="document.getElementById('thresholdValue').textContent = this.value + '%'">
            <div style="font-size: 12px; color: #6c757d; margin-top: 4px;">
              只显示相似度高于此值的结果
            </div>
          </div>

          <button id="initBtn"
            style="width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 16px;">
            初始化搜索引擎
          </button>

          <div id="status" class="status-indicator loading" style="display: none;">
            <div class="loading-spinner"></div>
            <span>等待初始化...</span>
          </div>
          <div class="progress-bar" style="display: none;">
            <div id="progress" class="progress-fill"></div>
          </div>
        </div>

        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-label">已索引文档</div>
            <div id="docCount" class="stat-value">0</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">文本块数量</div>
            <div id="chunkCount" class="stat-value">0</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">向量维度</div>
            <div id="dimension" class="stat-value">-</div>
          </div>
        </div>

        <div class="search-section" style="margin-top: 24px">
          <div class="card-title">
            <span>🔍</span>
            <span>语义搜索</span>
          </div>
          <div class="search-box">
            <input type="text" id="searchInput" class="search-input" placeholder="输入搜索内容... (例如: 机器学习)" value="机器学习" />
            <button id="searchBtn" class="search-btn" disabled>搜索</button>
          </div>
          <div id="results" class="results-section"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">
          <span>📝</span>
          <span>运行日志</span>
        </div>
        <div class="log-section">
          <div id="log" class="log"></div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ==================== 导入依赖 ====================
    import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js';
    // 使用本地的 hnswlib（从 node_modules 加载）
    import { loadHnswlib } from './node_modules/hnswlib-wasm-static/dist/hnswlib.js';

    const log = [];

    // ==================== 工具函数 ====================
    function addLog(message, type = "info") {
      const time = new Date().toLocaleTimeString();
      const logDiv = document.getElementById("log");
      const entry = document.createElement("div");
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<span class="log-time">[${time}]</span>${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      log.push({ time, message, type });
      console.log(`[${time}] ${message}`);
    }

    function updateStatus(message, type = "loading") {
      const statusDiv = document.getElementById("status");
      statusDiv.style.display = 'flex';
      statusDiv.className = `status-indicator ${type}`;

      let icon = '<div class="loading-spinner"></div>';
      if (type === "success") icon = '<span>✓</span>';
      if (type === "error") icon = '<span>✗</span>';

      statusDiv.innerHTML = `${icon}<span>${message}</span>`;
    }

    function updateProgress(percent) {
      const progressBar = document.querySelector(".progress-bar");
      const progressFill = document.getElementById("progress");
      progressBar.style.display = 'block';
      progressFill.style.width = `${percent}%`;
    }

    function updateStats() {
      document.getElementById("docCount").textContent = indexer?.documents?.size || 0;
      document.getElementById("chunkCount").textContent = indexer?.vectorDatabase?.docCount || 0;
    }

    function displayResults(results) {
      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = "";

      if (results.length === 0) {
        resultsDiv.innerHTML = '<div style="text-align: center; color: #6c757d; padding: 40px;">未找到相关结果</div>';
        return;
      }

      results.forEach((result, index) => {
        const item = document.createElement("div");
        item.className = "result-item";

        // 根据相似度设置边框颜色
        let borderColor = '#667eea'; // 默认蓝色
        if (result.similarity > 0.8) borderColor = '#66bb6a'; // 高相似度绿色
        else if (result.similarity < 0.6) borderColor = '#ffb74d'; // 低相似度橙色

        item.style.borderLeftColor = borderColor;

        item.innerHTML = `
          <div class="result-header">
            <div class="result-title">${result.title || '未命名文档'}</div>
            <div class="result-similarity" style="background: ${borderColor};">${(result.similarity * 100).toFixed(1)}%</div>
          </div>
          <div class="result-content">${result.text}</div>
          <div class="result-meta">
            来源: ${result.url || result.pageId} | 
            位置: ${result.startIdx}-${result.endIdx} |
            距离: ${result.distance?.toFixed(4) || 'N/A'}
          </div>
        `;
        resultsDiv.appendChild(item);
      });
    }

    // ==================== TextChunker ====================
    class TextChunker {
      constructor(options = {}) {
        this.chunkSize = options.chunkSize || 500;
        this.overlap = options.overlap || 50;
        this.minChunkSize = options.minChunkSize || 100;
      }

      chunkText(content, title = '') {
        if (!content || content.trim().length === 0) {
          return [];
        }

        const cleanContent = content.replace(/\s+/g, ' ').trim();
        const sentences = this.splitIntoSentences(cleanContent);
        const chunks = [];
        let currentChunk = [];
        let currentLength = 0;

        for (const sentence of sentences) {
          const sentenceLength = sentence.length;

          if (currentLength + sentenceLength > this.chunkSize && currentChunk.length > 0) {
            const chunkText = currentChunk.join(' ');
            if (chunkText.length >= this.minChunkSize) {
              chunks.push({
                text: chunkText,
                startIdx: chunks.length > 0 ? chunks[chunks.length - 1].endIdx - this.overlap : 0,
                endIdx: chunks.length > 0 ? chunks[chunks.length - 1].endIdx + chunkText.length - this.overlap : chunkText.length,
                title,
              });
            }

            const overlapSentences = currentChunk.slice(-Math.ceil(this.overlap / 100));
            currentChunk = overlapSentences;
            currentLength = overlapSentences.reduce((sum, s) => sum + s.length, 0);
          }

          currentChunk.push(sentence);
          currentLength += sentenceLength;
        }

        if (currentChunk.length > 0) {
          const chunkText = currentChunk.join(' ');
          if (chunkText.length >= this.minChunkSize) {
            chunks.push({
              text: chunkText,
              startIdx: chunks.length > 0 ? chunks[chunks.length - 1].endIdx - this.overlap : 0,
              endIdx: chunks.length > 0 ? chunks[chunks.length - 1].endIdx + chunkText.length - this.overlap : chunkText.length,
              title,
            });
          }
        }

        return chunks;
      }

      splitIntoSentences(content) {
        const sentenceEndings = /([.!?;。！？；]+[\s\n]*)/g;
        const parts = content.split(sentenceEndings);
        const sentences = [];

        for (let i = 0; i < parts.length; i += 2) {
          const text = parts[i];
          const ending = parts[i + 1] || '';
          if (text.trim()) {
            sentences.push((text + ending).trim());
          }
        }

        return sentences.length > 0 ? sentences : [content];
      }
    }

    // ==================== SemanticEngine ====================
    class SemanticEngine {
      constructor(config = {}) {
        this.modelName = config.modelName || 'Xenova/multilingual-e5-small';
        // 根据模型自动设置维度
        const defaultDimension = this.modelName.includes('base') ? 768 : 384;
        this.dimension = config.dimension || defaultDimension;
        this.useQuantized = config.useQuantized !== false;

        this.pipe = null;
        this.isInitialized = false;

        // 配置 transformers.js 环境
        env.allowLocalModels = false;
        env.useBrowserCache = true;
        env.allowRemoteModels = true;

        addLog('SemanticEngine 配置完成', 'info');
      }

      async initialize() {
        if (this.isInitialized) return;

        try {
          addLog(`正在加载模型: ${this.modelName}...`, 'info');
          addLog('提示: 首次运行会下载模型 (约 116MB)，请稍候', 'warning');

          const startTime = Date.now();

          this.pipe = await pipeline('feature-extraction', this.modelName, {
            quantized: this.useQuantized,
          });

          const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
          addLog(`✓ 模型加载完成 (耗时: ${elapsed}秒)`, 'success');

          this.isInitialized = true;
        } catch (error) {
          addLog(`✗ 模型加载失败: ${error.message}`, 'error');
          throw error;
        }
      }

      async getEmbedding(text) {
        if (!this.isInitialized) {
          await this.initialize();
        }

        try {
          const output = await this.pipe(text, { pooling: 'mean', normalize: true });
          const embedding = Array.from(output.data);

          // 调试：显示生成的向量信息
          console.log('生成 embedding:', {
            文本长度: text.length,
            文本预览: text.substring(0, 50) + '...',
            向量维度: embedding.length,
            向量前5个值: embedding.slice(0, 5),
            向量范围: [Math.min(...embedding), Math.max(...embedding)]
          });

          return embedding;
        } catch (error) {
          console.error('生成向量失败:', error);
          throw error;
        }
      }

      async getEmbeddingsBatch(texts) {
        if (!this.isInitialized) {
          await this.initialize();
        }

        const embeddings = [];
        for (const text of texts) {
          const embedding = await this.getEmbedding(text);
          embeddings.push(embedding);
        }
        return embeddings;
      }
    }

    // ==================== VectorDatabase ====================
    class VectorDatabase {
      constructor(config = {}) {
        this.dimension = config.dimension || 768;
        this.maxElements = config.maxElements || 10000;
        this.M = config.M || 16;
        this.efConstruction = config.efConstruction || 200;
        this.efSearch = config.efSearch || 50;

        this.hnswlib = null;
        this.index = null;
        this.documents = new Map();
        this.docCount = 0;
        this.isInitialized = false;
      }

      async initialize() {
        if (this.isInitialized) return;

        try {
          addLog('正在初始化向量数据库（WASM 高性能版）...', 'info');

          this.hnswlib = await loadHnswlib();
          addLog('✓ WASM 模块加载完成', 'success');

          this.index = new this.hnswlib.HierarchicalNSW('cosine', this.dimension, 'vector_index.bin');
          this.index.initIndex(this.maxElements, this.M, this.efConstruction, 200);
          this.index.setEfSearch(this.efSearch);

          addLog('✓ 向量数据库初始化完成', 'success');
          this.isInitialized = true;
        } catch (error) {
          addLog(`✗ 向量数据库初始化失败: ${error.message}`, 'error');
          throw error;
        }
      }

      async addDocument(pageId, url, title, chunk, embedding) {
        if (!this.isInitialized) {
          await this.initialize();
        }

        try {
          const docId = this.docCount;

          // 确保 embedding 是普通数组
          const cleanEmbedding = Array.isArray(embedding)
            ? embedding
            : Array.from(embedding);

          // 创建 VectorFloat 对象（hnswlib-wasm-static 要求）
          let vectorToAdd;
          try {
            if (this.hnswlib && this.hnswlib.VectorFloat) {
              vectorToAdd = new this.hnswlib.VectorFloat();
              for (let i = 0; i < cleanEmbedding.length; i++) {
                vectorToAdd.push_back(cleanEmbedding[i]);
              }
            } else {
              vectorToAdd = cleanEmbedding;
            }

            // addPoint(vector, label, replaceDeleted)
            this.index.addPoint(vectorToAdd, docId, false);

            // 清理 VectorFloat 对象
            if (vectorToAdd && typeof vectorToAdd.delete === 'function') {
              vectorToAdd.delete();
            }
          } catch (vectorError) {
            console.error('VectorFloat 方式失败，尝试备用方案:', vectorError);
            this.index.addPoint(cleanEmbedding, docId, false);
          }

          this.documents.set(docId, {
            pageId,
            url,
            title,
            text: chunk.text,
            startIdx: chunk.startIdx,
            endIdx: chunk.endIdx,
          });

          this.docCount++;
        } catch (error) {
          console.error('添加文档失败:', error);
          throw error;
        }
      }

      async search(queryEmbedding, topK = 10) {
        if (!this.isInitialized) {
          throw new Error('向量数据库未初始化');
        }

        if (this.docCount === 0) {
          return [];
        }

        try {
          // 确保 queryEmbedding 是普通数组
          const cleanQuery = Array.isArray(queryEmbedding)
            ? queryEmbedding
            : Array.from(queryEmbedding);

          // 创建 VectorFloat 对象（hnswlib-wasm-static 要求）
          let vectorQuery;
          try {
            if (this.hnswlib && this.hnswlib.VectorFloat) {
              vectorQuery = new this.hnswlib.VectorFloat();
              for (let i = 0; i < cleanQuery.length; i++) {
                vectorQuery.push_back(cleanQuery[i]);
              }
            } else {
              vectorQuery = cleanQuery;
            }

            const result = this.index.searchKnn(vectorQuery, Math.min(topK, this.docCount), undefined);

            // 清理 VectorFloat 对象
            if (vectorQuery && typeof vectorQuery.delete === 'function') {
              vectorQuery.delete();
            }

            const results = [];
            for (let i = 0; i < result.neighbors.length; i++) {
              const docId = result.neighbors[i];
              const distance = result.distances[i];
              const similarity = 1 - distance;

              const doc = this.documents.get(docId);
              if (doc) {
                results.push({
                  ...doc,
                  similarity,
                  distance,
                });
              }
            }

            return results.sort((a, b) => b.similarity - a.similarity);
          } catch (vectorError) {
            console.error('VectorFloat 搜索失败，尝试备用方案:', vectorError);
            const result = this.index.searchKnn(cleanQuery, Math.min(topK, this.docCount), undefined);

            const results = [];
            for (let i = 0; i < result.neighbors.length; i++) {
              const docId = result.neighbors[i];
              const distance = result.distances[i];
              const similarity = 1 - distance;

              const doc = this.documents.get(docId);
              if (doc) {
                results.push({
                  ...doc,
                  similarity,
                  distance,
                });
              }
            }

            return results.sort((a, b) => b.similarity - a.similarity);
          }
        } catch (error) {
          console.error('搜索失败:', error);
          throw error;
        }
      }
    }

    // ==================== ContentIndexer ====================
    class ContentIndexer {
      constructor(config = {}) {
        this.textChunker = new TextChunker({
          chunkSize: config.chunkSize || 500,
          overlap: config.overlap || 50,
        });

        this.semanticEngine = new SemanticEngine({
          modelName: config.modelName || 'Xenova/multilingual-e5-small',
          dimension: config.dimension || 384,
        });

        this.vectorDatabase = new VectorDatabase({
          dimension: config.dimension || 768,  // 默认使用 base 模型的维度
        });

        this.documents = new Map();
        this.isInitialized = false;
      }

      async initialize() {
        if (this.isInitialized) return;

        try {
          addLog('开始初始化内容索引器...', 'info');
          updateProgress(10);

          await Promise.all([
            this.semanticEngine.initialize(),
            this.vectorDatabase.initialize(),
          ]);

          updateProgress(50);
          addLog('✓ 内容索引器初始化完成', 'success');
          this.isInitialized = true;
        } catch (error) {
          addLog(`✗ 内容索引器初始化失败: ${error.message}`, 'error');
          throw error;
        }
      }

      async indexDocument(pageId, url, title, content) {
        if (!this.isInitialized) {
          await this.initialize();
        }

        try {
          const chunks = this.textChunker.chunkText(content, title);
          addLog(`文档 "${title}" 分块完成: ${chunks.length} 个块`, 'info');

          for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            const embedding = await this.semanticEngine.getEmbedding(chunk.text);
            await this.vectorDatabase.addDocument(pageId, url, title, chunk, embedding);

            if ((i + 1) % 5 === 0) {
              updateProgress(50 + (i + 1) / chunks.length * 40);
            }
          }

          this.documents.set(pageId, { url, title, chunkCount: chunks.length });
          addLog(`✓ 文档 "${title}" 索引完成`, 'success');
        } catch (error) {
          addLog(`✗ 文档索引失败: ${error.message}`, 'error');
          throw error;
        }
      }

      async search(query, topK = 10) {
        if (!this.isInitialized) {
          throw new Error('内容索引器未初始化');
        }

        try {
          addLog(`开始搜索: "${query.substring(0, 50)}..."`, 'info');
          console.log('=== 开始搜索 ===');
          console.log('查询文本:', query);

          const queryEmbedding = await this.semanticEngine.getEmbedding(query);
          console.log('查询向量:', queryEmbedding.slice(0, 5), '...');

          const results = await this.vectorDatabase.search(queryEmbedding, topK);

          console.log('搜索结果:', results.map(r => ({
            标题: r.title,
            相似度: (r.similarity * 100).toFixed(2) + '%',
            距离: r.distance,
            文本预览: r.text.substring(0, 50) + '...'
          })));

          addLog(`✓ 搜索完成，找到 ${results.length} 个结果`, 'success');
          return results;
        } catch (error) {
          addLog(`✗ 搜索失败: ${error.message}`, 'error');
          throw error;
        }
      }
    }

    // ==================== 验证测试 ====================
    async function runValidationTests() {
      try {
        addLog("测试 1: 搜索 '机器学习'（应该匹配 AI 文档）", "info");
        const test1 = await indexer.search("机器学习", 3);
        addLog(`  结果: ${test1[0].title}, 相似度: ${(test1[0].similarity * 100).toFixed(2)}%`,
          test1[0].title.includes("人工智能") && test1[0].similarity > 0.6 ? "success" : "error");

        addLog("测试 2: 搜索 'React Vue'（应该匹配 Web 文档）", "info");
        const test2 = await indexer.search("React Vue", 3);
        addLog(`  结果: ${test2[0].title}, 相似度: ${(test2[0].similarity * 100).toFixed(2)}%`,
          test2[0].title.includes("Web") && test2[0].similarity > 0.6 ? "success" : "error");

        addLog("测试 3: 搜索 '统计学'（应该匹配数据科学文档）", "info");
        const test3 = await indexer.search("统计学", 3);
        addLog(`  结果: ${test3[0].title}, 相似度: ${(test3[0].similarity * 100).toFixed(2)}%`,
          test3[0].title.includes("数据") && test3[0].similarity > 0.6 ? "success" : "error");

        addLog("✓ 验证测试完成！语义搜索正常工作", "success");
      } catch (error) {
        addLog(`验证测试失败: ${error.message}`, "error");
      }
    }

    // ==================== 主程序 ====================
    let indexer = null;

    // 初始化
    async function initialize() {
      try {
        const modelSelect = document.getElementById("modelSelect");
        const selectedModel = modelSelect.value;

        const modelConfig = {
          small: {
            name: "Xenova/multilingual-e5-small",
            dimension: 384,
            displayName: "multilingual-e5-small"
          },
          base: {
            name: "Xenova/multilingual-e5-base",
            dimension: 768,
            displayName: "multilingual-e5-base"
          }
        };

        const config = modelConfig[selectedModel];

        addLog(`开始初始化语义搜索引擎（使用 ${config.displayName}）...`, "info");
        updateStatus("正在初始化...", "loading");

        // 更新显示
        document.getElementById("currentModel").textContent = config.displayName;
        document.getElementById("dimension").textContent = config.dimension;

        indexer = new ContentIndexer({
          modelName: config.name,
          dimension: config.dimension,
        });

        await indexer.initialize();
        updateProgress(60);

        // 索引示例文档
        addLog("开始索引示例文档...", "info");

        const sampleDocs = [
          {
            id: "doc1",
            url: "https://example.com/ai",
            title: "人工智能简介",
            content: "人工智能（Artificial Intelligence, AI）是计算机科学的一个分支，致力于创建能够执行通常需要人类智能的任务的系统。机器学习是人工智能的一个子领域，它使计算机能够从数据中学习而无需明确编程。深度学习是机器学习的一个分支，使用多层神经网络来处理复杂的模式识别任务。",
          },
          {
            id: "doc2",
            url: "https://example.com/web",
            title: "Web 开发技术",
            content: "Web 开发涉及创建网站和 Web 应用程序。前端开发主要使用 HTML、CSS 和 JavaScript 构建用户界面。后端开发处理服务器端逻辑、数据库和 API。现代 Web 开发框架如 React、Vue 和 Angular 使构建复杂的用户界面变得更容易。",
          },
          {
            id: "doc3",
            url: "https://example.com/data",
            title: "数据科学基础",
            content: "数据科学是一个跨学科领域，使用科学方法、流程、算法和系统从数据中提取知识和洞察。它结合了统计学、数据分析、机器学习和相关方法来理解和分析实际现象。数据可视化是数据科学的重要组成部分，帮助人们理解复杂的数据模式。",
          }, {
            id: "doc4",
            url: "https://example.com/blockchain",
            title: "区块链技术",
            content: "区块链是一种分布式账本技术，通过加密算法和共识机制确保数据的安全性和不可篡改性。比特币是第一个成功的区块链应用，而以太坊引入了智能合约功能。区块链技术在金融、供应链管理、数字身份验证等领域有广泛应用。去中心化是区块链的核心特征之一。",
          },
          {
            id: "doc5",
            url: "https://example.com/mobile",
            title: "移动应用开发",
            content: "移动应用开发包括为 iOS 和 Android 平台创建应用程序。原生开发使用 Swift（iOS）和 Kotlin（Android），提供最佳性能。跨平台框架如 React Native 和 Flutter 允许使用单一代码库开发多平台应用。移动应用需要考虑触摸交互、电池优化和不同屏幕尺寸的适配。",
          },
          {
            id: "doc6",
            url: "https://example.com/cloud",
            title: "云计算服务",
            content: "云计算提供按需访问的计算资源，包括服务器、存储、数据库和网络。主要的云服务提供商包括 AWS、Azure 和 Google Cloud。云计算模式包括 IaaS（基础设施即服务）、PaaS（平台即服务）和 SaaS（软件即服务）。云计算具有弹性扩展、成本效益和全球可用性等优势。",
          },
          {
            id: "doc7",
            url: "https://example.com/security",
            title: "网络安全防护",
            content: "网络安全涉及保护计算机系统和网络免受数字攻击。常见的安全威胁包括恶意软件、钓鱼攻击、DDoS 攻击和 SQL 注入。安全措施包括防火墙、加密、身份验证和访问控制。定期更新软件、使用强密码和员工安全培训是保护系统的重要步骤。渗透测试可以帮助发现系统漏洞。",
          },
          {
            id: "doc8",
            url: "https://example.com/database",
            title: "数据库管理系统",
            content: "数据库管理系统（DBMS）用于存储、管理和检索数据。关系型数据库如 MySQL、PostgreSQL 使用 SQL 查询语言和表格结构。NoSQL 数据库如 MongoDB、Redis 提供更灵活的数据模型，适合大规模和非结构化数据。数据库设计需要考虑规范化、索引优化和事务处理。",
          },
          {
            id: "doc9",
            url: "https://example.com/devops",
            title: "DevOps 实践",
            content: "DevOps 是开发（Development）和运维（Operations）的结合，旨在缩短开发周期并提供持续交付。核心实践包括持续集成（CI）、持续部署（CD）、基础设施即代码和自动化测试。常用工具包括 Docker、Kubernetes、Jenkins 和 GitLab CI/CD。监控和日志分析对于维护系统稳定性至关重要。",
          },
          {
            id: "doc10",
            url: "https://example.com/nlp",
            title: "自然语言处理",
            content: "自然语言处理（NLP）是人工智能的一个分支，专注于计算机与人类语言的交互。应用包括机器翻译、情感分析、文本摘要和聊天机器人。现代 NLP 技术基于深度学习模型，如 Transformer、BERT 和 GPT。词向量和语言模型是 NLP 的基础技术，用于理解单词和句子的语义。",
          },
          {
            id: "doc11",
            url: "https://example.com/cv",
            title: "计算机视觉",
            content: "计算机视觉使计算机能够从图像和视频中获取有意义的信息。应用包括人脸识别、物体检测、图像分割和自动驾驶。卷积神经网络（CNN）是计算机视觉的核心技术。OpenCV 是一个流行的计算机视觉库，提供了丰富的图像处理功能。图像增强和特征提取是预处理的重要步骤。",
          },
          {
            id: "doc12",
            url: "https://example.com/iot",
            title: "物联网技术",
            content: "物联网（IoT）连接物理设备到互联网，实现数据收集和远程控制。智能家居、工业自动化和智慧城市是 IoT 的典型应用。物联网系统包括传感器、网关、云平台和应用程序。常用的通信协议包括 MQTT、CoAP 和 LoRaWAN。边缘计算可以减少延迟并提高 IoT 系统的效率。",
          },
          {
            id: "doc13",
            url: "https://example.com/testing",
            title: "软件测试方法",
            content: "软件测试确保应用程序的质量和可靠性。测试类型包括单元测试、集成测试、系统测试和用户验收测试。自动化测试使用工具如 Selenium、Jest 和 Pytest 提高测试效率。测试驱动开发（TDD）和行为驱动开发（BDD）是流行的测试方法论。代码覆盖率和缺陷跟踪是测试管理的重要指标。",
          },
          {
            id: "doc14",
            url: "https://example.com/design-patterns",
            title: "设计模式精解",
            content: "设计模式是软件设计中常见问题的可重用解决方案。创建型模式包括单例、工厂和建造者模式。结构型模式如适配器、装饰器和代理模式。行为型模式包括观察者、策略和命令模式。设计模式提高代码的可维护性、可扩展性和可读性。SOLID 原则是面向对象设计的基础。",
          },
          {
            id: "doc15",
            url: "https://example.com/microservices",
            title: "微服务架构",
            content: "微服务架构将应用程序拆分为小型、独立的服务，每个服务负责特定的业务功能。服务之间通过 API 通信，通常使用 REST 或 gRPC。微服务的优势包括独立部署、技术多样性和故障隔离。服务发现、API 网关和分布式追踪是微服务架构的关键组件。容器化和编排工具如 Docker 和 Kubernetes 简化了微服务的部署。",
          },
        ];

        for (let i = 0; i < sampleDocs.length; i++) {
          const doc = sampleDocs[i];
          await indexer.indexDocument(doc.id, doc.url, doc.title, doc.content);
          updateProgress(60 + (i + 1) / sampleDocs.length * 30);
        }

        updateProgress(100);
        updateStatus("✓ 初始化完成！可以开始搜索", "success");
        addLog("✓ 系统就绪，可以开始搜索", "success");

        // 运行验证测试
        addLog("=== 运行验证测试 ===", "info");
        await runValidationTests();

        document.getElementById("searchBtn").disabled = false;
        updateStats();
      } catch (error) {
        console.error("初始化失败:", error);
        updateStatus(`✗ 初始化失败: ${error.message}`, "error");
        addLog(`初始化失败: ${error.message}`, "error");
      }
    }

    // 搜索
    async function search() {
      const query = document.getElementById("searchInput").value.trim();
      if (!query) {
        addLog("请输入搜索内容", "warning");
        return;
      }

      if (!indexer || !indexer.isInitialized) {
        addLog("系统尚未初始化完成", "warning");
        return;
      }

      try {
        updateStatus("正在搜索...", "loading");

        // 获取相似度阈值
        const thresholdSlider = document.getElementById("thresholdSlider");
        const threshold = parseInt(thresholdSlider.value) / 100;

        // 获取更多结果用于过滤（类似 mcp-chrome 的做法）
        const allResults = await indexer.search(query, 50);

        // 过滤低于阈值的结果
        const filteredResults = allResults.filter(r => r.similarity >= threshold);

        // 只保留前 10 个
        const topResults = filteredResults.slice(0, 10);

        addLog(`✓ 搜索完成：找到 ${allResults.length} 个结果，过滤后 ${filteredResults.length} 个（阈值: ${(threshold * 100).toFixed(0)}%），显示前 ${topResults.length} 个`, "success");

        displayResults(topResults);
        updateStatus(`✓ 找到 ${topResults.length} 个结果（相似度 ≥ ${(threshold * 100).toFixed(0)}%）`, "success");
      } catch (error) {
        console.error("搜索失败:", error);
        updateStatus(`✗ 搜索失败: ${error.message}`, "error");
        addLog(`搜索失败: ${error.message}`, "error");
      }
    }

    // 事件监听
    document.getElementById("searchBtn").addEventListener("click", search);
    document.getElementById("searchInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        search();
      }
    });

    document.getElementById("initBtn").addEventListener("click", async () => {
      const initBtn = document.getElementById("initBtn");
      const modelSelect = document.getElementById("modelSelect");

      // 禁用按钮和选择器
      initBtn.disabled = true;
      modelSelect.disabled = true;
      initBtn.textContent = "初始化中...";

      await initialize();
    });

    // 页面加载完成
    addLog("页面加载完成", "info");
    addLog("✓ 使用 CDN 版 transformers.js + WASM 向量数据库（高性能）", "success");
    addLog("请选择模型并点击【初始化搜索引擎】按钮", "info");
  </script>
</body>

</html>